#include <iostream>
#include <fstream>
#include <string>
#include <stack>
#include <list>
using namespace std;


int main() {

	list <string> lst;
	list <string> saved;

	string xml_file = " <user> <id> 4 </id> <id> 3 </id> </user> <user> <id> 5 </id> </user> ";


	for (int i = 0; i < xml_file.length(); i++)
	{
		string start = "";
		string value = "";

		if (xml_file[i] == '<')
		{
			switch (xml_file[i + 1]) {
			case'!':
				continue;
				break;
			case'?':
				continue;
				break;

			default: // push into the stack 
			{
				//for tag
				for (i = i + 1; xml_file[i] != '>'; i++)
				{
					start = start + xml_file[i];
				}
				lst.push_back(start);

				//for value
				int k;
				for (k = i + 1; xml_file[k] != '<' && k < xml_file.length(); k++) //loop till the opening tag
				{  //not value
					if (xml_file[k] == ' ' && xml_file[k - 1] == ' ' || xml_file[k] == ' ' && xml_file[k - 1] == '>' || xml_file[k] == '<' && xml_file[k - 1] == ' ' || xml_file[k] == '\n' || xml_file[k] == '\t') continue;
					else value = value + xml_file[k]; // a value
				}
				if (value != "") lst.push_back(value);

			}
			} // switch brackit		
		}
		else continue; // if not "<" 
	}







	// now we have a list of the tags and values 




	auto ptr = lst.begin(); // head of the lst


	// we turn from lst to saved
	for (; ptr != lst.end();) {
		string s = *ptr;  // data of the node

		//in case of opening tag ,, and here there is 2 cases add value or add group brackit
		if (s[0] != '/' && s[0] != '  ' && s[0] != '{' && s[0] != '}' && s[0] != ',' && s[0] != '[' && s[0] != ']') { // i added not = ] or [

			if (next(ptr, 1) != lst.end() && next(ptr, 2) != lst.end()) { //check there is next and after next
				
				// عشان ميكررش اسامي
				if (ptr == lst.begin()) saved.push_back(*ptr);
				if (ptr != lst.begin() && '/' +  * ptr != *prev(ptr , 1 ) ) saved.push_back(*ptr);


				//value
				string two_next = *next(ptr, 2); // check that it doesn't exceed the list
				if ('/' + s == two_next) {       // one line xml tags
					saved.push_back(*next(ptr)); // push the value
					ptr = next(ptr, 2); // increase ptr with 2 ptr  = ptr + 2 to skip the value node 
					continue;
				}

				//group brackit
				if ('/' + s != two_next) {  // group opening tag
					saved.push_back("{");	//lst.emplace(next(ptr), 1, '{');
					ptr++;
					continue;
				}
			}
		}


		//in case of closing tag
		if (s[0] == '/') { 

			// }
			string two_prev = *prev(ptr, 2);
			if (s != '/' + two_prev) saved.push_back("}"); //not one line, so group closing tag 
			

			// , 
			if (next(ptr) != lst.end()) //not exceed the length
			{
				string next_node = *next(ptr, 1); // check what's after me

				//in case of name add <<<<< , >>>>>> 
				if (next_node[0] != '/' && next_node[0] != '}' && next_node[0] != ',') saved.push_back(",");




				
				// name as my name 
				if (*ptr == '/' + next_node) { 
					auto srch = saved.end();
					srch--;

					
					for (; srch != saved.begin();) {
						if ('/' + *srch != *ptr) {
							srch--;
							continue;
						}
						saved.emplace(next(srch), 1, '[');
						break;
					}
					if ('/' + *srch == *ptr && srch == saved.begin()) saved.emplace(next(srch), 1, '[');
				}




			}
			
			ptr++;
		}
	}





	auto pt = saved.begin();
	for (pt = saved.begin(); pt != saved.end(); pt++) {
		cout << *pt << '\n';
	}













}
