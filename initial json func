#include <iostream>
#include <fstream>
#include <string>
#include <stack>
#include <list>
using namespace std;




int main() {
	//do try ...catch to convert string into number

	//code proplem is only with the array brakits and repeating the non consecutive opening tags with same name


	list <string> lst;
	list <string> saved;

	string xml_file = "<users>			<user> <id>1</id>  <name> Ahmed Ali </name>    <posts>      <post>        <body>       bla bla bla        </body>        <topics>        <topic>        economy        </topic>        <topic>        finance        </topic>        </topics>        </post>        <post>        <body>    bla       </body>        <topics>        <topic>        solar_energy        </topic>        </topics>        </post>        </posts>        <followers>        <follower>        <id>2</id>        </follower>        <follower>        <id>3</id>        </follower>        </followers>        </user>        <user>        <id>2</id>        <name>Yasser Ahmed</name>        <posts>        <post>        <body>        Lorem      </body>        <topics>        <topic>        education        </topic>        </topics>        </post>        </posts>        <followers>        <follower>        <id>1 </id>        </follower>        </followers>        </user>        <user>        <id>3 </id>        <name>Mohamed Sherif</name>        <posts>        <post>        <body>        Lorem     </body>        <topics>        <topic>        sports        </topic>        </topics>        </post>        </posts>        <followers>        <follower>        <id>1</id>        </follower>        </followers>        </user>        </users>";
	//"<user> <id>4</id> <id>3</id> </user>";

	for (int i = 0; i < xml_file.length(); i++)
	{
		string start = "";
		string value = "";

		if (xml_file[i] == '<')
		{
			switch (xml_file[i + 1]) {
			case'!':
				continue;
				break;
			case'?':
				continue;
				break;

			default: // push into the stack 
			{
				int k;
				for (i = i + 1; xml_file[i] != '>'; i++)
				{

					start = start + xml_file[i];
				}

				lst.push_back(start);
				bool flag = true; // flag to skip the first space in the value
				for (k = i + 1; xml_file[k] != '<' && k < xml_file.length(); k++) //loop till the opening tag
				{
					if (xml_file[k] == ' ' && xml_file[k-1] == ' ' || xml_file[k] == ' ' && xml_file[k - 1] == '>' || xml_file[k] == '<' && xml_file[k - 1] == ' ' || xml_file[k] == '\n' || xml_file[k] == '\t') {
						//flag = false;
						continue;
					}
					else
					{
						value = value + xml_file[k];
					}
				}
				if (value == "" ) break;
				else lst.push_back(value); //s.push(value);
			}
			}
		}
		else continue;
	}





	// now you have a list of strings

	auto ptr = lst.begin(); // head of the lst
	
	list <string> cl_stk;
	list <string> op_tag;


	bool once = false;
	string last = ""; // value of last opening tag node

	for (; ptr != lst.end();) { // ptr for 
		string s = *ptr;  // data of the node
		//in case of opening tag
		if (s[0] != '/' && s[0] != '  ' && s[0] != '{' && s[0] != '}' && s[0] != ',' && s[0] != '[' && s[0] != ']') { // i added not = ] or [

		if (next(ptr, 1) != lst.end() && next(ptr, 2) != lst.end()) {

			if (*ptr != last) {
				saved.push_back(*ptr); // in case it is not the array case
				last = *ptr;
			}
			else {
				//op_tag.push_back(*ptr);
				last = *ptr;
			}
			string two_next = *next(ptr, 2); // check that it doesn't exceed the list
			if ('/' + s == two_next) {       // one line xml tags
				saved.push_back(*next(ptr)); // push the value
				ptr = next(ptr, 2); // increase ptr with 2 ptr  = ptr + 2 to skip the value node 
				continue;
			}
			if ('/' + s != two_next) {  // group opening tag
				saved.push_back("{");	//lst.emplace(next(ptr), 1, '{');
				ptr++;
				continue;
			}
		}

		}

		//in case of closing tag
		if (s[0] == '/') { // increase ptr++
			string two_prev = *prev(ptr, 2);
			if (s != '/' + two_prev) { // group closing tag , not one line
				saved.push_back("}"); //lst.emplace(next(ptr), 1, '}');
			}

			if (next(ptr) != lst.end())
			{
				string next_node = *next(ptr, 1); // check what's after me 
				//in case of name
				if (next_node[0] != '/' && next_node[0] != '}' && next_node[0] != ',') // the next is a name // edit 2: it won't be any of them as i wrote them in a new list
				{
					saved.push_back(","); //lst.emplace(next(ptr), 1, ','); 

				}
				//next is a name and as my name
				if (next_node[0] != '/' && s == '/' + next_node) // s = /id , next = id <<<<array []>>
				{
					if (once == false) { 
						cl_stk.push_front(s); // added /d to stack to remember it 
						op_tag.push_front(next_node);
						once = true; //this end tag saved once
					}
					/*cl_stk.push_front(s);
					op_stk.push_back(next_node);
					dlt.push_back(next_node);*/
				}
				//when it is the last closing tag on the array
				if (cl_stk.empty() != true && s == cl_stk.front() && s != '/' + next_node) // /id is == to the top of the stack and the next isn't my name
				{	//pop /id
					saved.push_back("]"); // close the array
					cl_stk.pop_front();
					once = false;
				}
			}
		}
		ptr++;
	}



	/* to insert the array brackit "[",
	1- do unique then
	2- for each node in the saved list check if it's == to the name int the op_tag stack
	3-then insert [ after it and then pop it */

	op_tag.unique();
	auto it = saved.begin();
	for (it = saved.begin(); it != saved.end() && op_tag.empty() != true; it++) {
		if (*it == op_tag.front()) {
			saved.emplace(next(it), 1, '[');
			it++;
			op_tag.pop_front();
		}
	}


	auto pt = saved.begin();
	for (pt = saved.begin(); pt != saved.end(); pt++) {

		cout << *pt << '\n';

	}




}
// *next(ptr,2) value of the node next the current with 2 positions
// next(ptr,2)   node after current node by two positions
// prev(ptr,0) current node ;
